package nildumu.ui;

import com.formdev.flatlaf.FlatLightLaf;
import com.intellij.uiDesigner.core.GridConstraints;
import com.intellij.uiDesigner.core.GridLayoutManager;
import nildumu.*;
import nildumu.mih.MethodInvocationHandler;
import org.fife.ui.autocomplete.*;
import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
import org.fife.ui.rsyntaxtextarea.SquiggleUnderlineHighlightPainter;
import org.fife.ui.rsyntaxtextarea.SyntaxConstants;
import org.fife.ui.rtextarea.RTextScrollPane;
import swp.LocatedSWPException;
import swp.lexer.Location;

import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;
import javax.swing.text.BadLocationException;
import java.awt.*;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.*;
import java.util.logging.Level;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static nildumu.Lattices.*;
import static nildumu.util.Util.p;

public class BasicUI {

    private void createUIComponents() {
        dotPanel = new DotPanel(this,
                getVarContent("autoRedraw", "false").equals("true"),
                b -> setVarContent("autoRedraw", b + ""));
    }

    /**
     * Method generated by IntelliJ IDEA GUI Designer
     * >>> IMPORTANT!! <<<
     * DO NOT edit this method OR call it in your code!
     *
     * @noinspection ALL
     */
    private void $$$setupUI$$$() {
        createUIComponents();
        rootPanel = new JPanel();
        rootPanel.setLayout(new GridLayoutManager(2, 1, new Insets(0, 0, 0, 0), -1, -1));
        final JSplitPane splitPane1 = new JSplitPane();
        splitPane1.setContinuousLayout(false);
        splitPane1.setDividerLocation(700);
        splitPane1.setOneTouchExpandable(true);
        rootPanel.add(splitPane1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, new Dimension(200, 200), null, 0, false));
        final JSplitPane splitPane2 = new JSplitPane();
        splitPane2.setContinuousLayout(true);
        splitPane2.setDividerLocation(375);
        splitPane2.setOrientation(0);
        splitPane1.setLeftComponent(splitPane2);
        final JTabbedPane tabbedPane1 = new JTabbedPane();
        tabbedPane1.setEnabled(true);
        splitPane2.setRightComponent(tabbedPane1);
        final JPanel panel1 = new JPanel();
        panel1.setLayout(new GridLayoutManager(1, 1, new Insets(0, 0, 0, 0), -1, -1));
        tabbedPane1.addTab("Leakage", panel1);
        final JScrollPane scrollPane1 = new JScrollPane();
        panel1.add(scrollPane1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));
        leakageTable = new JTable();
        scrollPane1.setViewportView(leakageTable);
        final RTextScrollPane rTextScrollPane1 = new RTextScrollPane();
        tabbedPane1.addTab("Preprocessed", rTextScrollPane1);
        ssaArea = new RSyntaxTextArea();
        ssaArea.setEditable(false);
        ssaArea.setText("");
        rTextScrollPane1.setViewportView(ssaArea);
        final RTextScrollPane rTextScrollPane2 = new RTextScrollPane();
        tabbedPane1.addTab("Without loops", rTextScrollPane2);
        withoutLoopsArea = new RSyntaxTextArea();
        withoutLoopsArea.setAnimateBracketMatching(false);
        withoutLoopsArea.setCodeFoldingEnabled(true);
        withoutLoopsArea.setEditable(false);
        withoutLoopsArea.setText("");
        rTextScrollPane2.setViewportView(withoutLoopsArea);
        final JPanel panel2 = new JPanel();
        panel2.setLayout(new GridLayoutManager(1, 1, new Insets(0, 0, 0, 0), -1, -1));
        tabbedPane1.addTab("Output", panel2);
        final JScrollPane scrollPane2 = new JScrollPane();
        panel2.add(scrollPane2, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));
        outputArea = new JTextArea();
        outputArea.setEditable(false);
        outputArea.setEnabled(true);
        outputArea.setText("");
        scrollPane2.setViewportView(outputArea);
        nodeValueScrollPane = new JScrollPane();
        nodeValueScrollPane.setHorizontalScrollBarPolicy(32);
        tabbedPane1.addTab("Node values", nodeValueScrollPane);
        nodeValueTable = new JTable();
        nodeValueTable.setAutoCreateRowSorter(true);
        nodeValueTable.setAutoResizeMode(4);
        nodeValueScrollPane.setViewportView(nodeValueTable);
        variableValueScrollPane = new JScrollPane();
        variableValueScrollPane.setHorizontalScrollBarPolicy(32);
        tabbedPane1.addTab("Variable values", variableValueScrollPane);
        variableValueTable = new JTable();
        variableValueTable.setAutoCreateRowSorter(true);
        variableValueTable.setAutoResizeMode(2);
        variableValueScrollPane.setViewportView(variableValueTable);
        final JPanel panel3 = new JPanel();
        panel3.setLayout(new GridLayoutManager(4, 9, new Insets(0, 0, 0, 0), -1, -1));
        splitPane2.setLeftComponent(panel3);
        final JPanel panel4 = new JPanel();
        panel4.setLayout(new BorderLayout(0, 0));
        panel3.add(panel4, new GridConstraints(1, 0, 1, 9, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
        inputScrollArea = new RTextScrollPane();
        inputScrollArea.setMinimumSize(new Dimension(200, 200));
        inputScrollArea.setPreferredSize(new Dimension(400, 200));
        panel4.add(inputScrollArea, BorderLayout.CENTER);
        inputArea = new RSyntaxTextArea();
        inputArea.setCloseCurlyBraces(true);
        inputArea.setCodeFoldingEnabled(true);
        inputArea.setPaintMarkOccurrencesBorder(true);
        inputArea.setPaintMatchedBracketPair(true);
        inputArea.setText("");
        inputScrollArea.setViewportView(inputArea);
        final JPanel panel5 = new JPanel();
        panel5.setLayout(new GridLayoutManager(1, 9, new Insets(0, 0, 0, 0), -1, -1));
        panel3.add(panel5, new GridConstraints(0, 0, 1, 9, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        storeSelectComboBox = new JComboBox();
        storeSelectComboBox.setEditable(true);
        Font storeSelectComboBoxFont = this.$$$getFont$$$(null, -1, -1, storeSelectComboBox.getFont());
        if (storeSelectComboBoxFont != null) storeSelectComboBox.setFont(storeSelectComboBoxFont);
        final DefaultComboBoxModel defaultComboBoxModel1 = new DefaultComboBoxModel();
        storeSelectComboBox.setModel(defaultComboBoxModel1);
        panel5.add(storeSelectComboBox, new GridConstraints(0, 0, 1, 8, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        storeButton = new JButton();
        storeButton.setText("\uD83D\uDDAA");
        storeButton.setToolTipText("Store the program as an example");
        panel5.add(storeButton, new GridConstraints(0, 8, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(5, -1), null, 0, false));
        final JPanel panel6 = new JPanel();
        panel6.setLayout(new BorderLayout(0, 0));
        panel3.add(panel6, new GridConstraints(2, 0, 1, 9, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        final JPanel panel7 = new JPanel();
        panel7.setLayout(new GridLayoutManager(1, 8, new Insets(0, 0, 0, 0), -1, -1));
        panel6.add(panel7, BorderLayout.NORTH);
        runButton = new JButton();
        runButton.setText("\uD83E\uDC92");
        runButton.setToolTipText("Request processing of the program");
        panel7.add(runButton, new GridConstraints(0, 4, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(10, -1), null, 0, false));
        stopButton = new JButton();
        stopButton.setText("⏹");
        panel7.add(stopButton, new GridConstraints(0, 5, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, 1, GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(10, -1), null, 0, false));
        modeComboBox = new JComboBox();
        panel7.add(modeComboBox, new GridConstraints(0, 7, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        autoRunCheckBox = new JCheckBox();
        autoRunCheckBox.setText("⮔");
        autoRunCheckBox.setToolTipText("Auto run the processing of the program");
        panel7.add(autoRunCheckBox, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        transformPlusCheckBox = new JCheckBox();
        transformPlusCheckBox.setText("+ → |");
        transformPlusCheckBox.setMnemonic('|');
        transformPlusCheckBox.setDisplayedMnemonicIndex(4);
        panel7.add(transformPlusCheckBox, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        final JLabel label1 = new JLabel();
        label1.setText("Mode");
        panel7.add(label1, new GridConstraints(0, 6, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        transformLoopsCheckBox = new JCheckBox();
        transformLoopsCheckBox.setEnabled(false);
        transformLoopsCheckBox.setText("loop → recursion");
        transformLoopsCheckBox.setToolTipText("transform loops into recursion, increases precision");
        panel7.add(transformLoopsCheckBox, new GridConstraints(0, 2, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        recordAlternativesCheckBox = new JCheckBox();
        recordAlternativesCheckBox.setEnabled(true);
        recordAlternativesCheckBox.setText("rec alt");
        recordAlternativesCheckBox.setToolTipText("record alternatives, only works with PMSAT based min-cut computation");
        panel7.add(recordAlternativesCheckBox, new GridConstraints(0, 3, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        final JPanel panel8 = new JPanel();
        panel8.setLayout(new GridLayoutManager(2, 1, new Insets(0, 0, 0, 0), -1, -1));
        panel6.add(panel8, BorderLayout.CENTER);
        methodHandlerSelectionComboxBox = new JComboBox();
        methodHandlerSelectionComboxBox.setEditable(true);
        panel8.add(methodHandlerSelectionComboxBox, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        final JPanel panel9 = new JPanel();
        panel9.setLayout(new GridLayoutManager(1, 10, new Insets(0, 0, 0, 0), -1, -1));
        panel8.add(panel9, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        fontSizeMultiplierComboBox = new JComboBox();
        final DefaultComboBoxModel defaultComboBoxModel2 = new DefaultComboBoxModel();
        defaultComboBoxModel2.addElement("100%");
        defaultComboBoxModel2.addElement("125%");
        defaultComboBoxModel2.addElement("150%");
        defaultComboBoxModel2.addElement("200%");
        defaultComboBoxModel2.addElement("300%");
        fontSizeMultiplierComboBox.setModel(defaultComboBoxModel2);
        panel9.add(fontSizeMultiplierComboBox, new GridConstraints(0, 5, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
        final JLabel label2 = new JLabel();
        label2.setText("Bit width:");
        panel9.add(label2, new GridConstraints(0, 6, 1, 3, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        bitWidthLabel = new JLabel();
        bitWidthLabel.setText("  ");
        panel9.add(bitWidthLabel, new GridConstraints(0, 9, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        final JLabel label3 = new JLabel();
        label3.setText("Font size");
        panel9.add(label3, new GridConstraints(0, 4, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        final JLabel label4 = new JLabel();
        label4.setText("Min-Cut");
        panel9.add(label4, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        minCutAlgoComboBox = new JComboBox();
        panel9.add(minCutAlgoComboBox, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        outputModeComboxBox = new JComboBox();
        panel9.add(outputModeComboxBox, new GridConstraints(0, 3, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        final JLabel label5 = new JLabel();
        label5.setText("Output");
        panel9.add(label5, new GridConstraints(0, 2, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        final JPanel panel10 = new JPanel();
        panel10.setLayout(new BorderLayout(0, 0));
        splitPane1.setRightComponent(panel10);
        panel10.add(dotPanel.$$$getRootComponent$$$(), BorderLayout.CENTER);
        parserErrorLabel = new JLabel();
        parserErrorLabel.setText("Label");
        rootPanel.add(parserErrorLabel, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
    }

    /**
     * @noinspection ALL
     */
    private Font $$$getFont$$$(String fontName, int style, int size, Font currentFont) {
        if (currentFont == null) return null;
        String resultName;
        if (fontName == null) {
            resultName = currentFont.getName();
        } else {
            Font testFont = new Font(fontName, Font.PLAIN, 10);
            if (testFont.canDisplay('a') && testFont.canDisplay('1')) {
                resultName = fontName;
            } else {
                resultName = currentFont.getName();
            }
        }
        return new Font(resultName, style >= 0 ? style : currentFont.getStyle(), size >= 0 ? size : currentFont.getSize());
    }

    /**
     * @noinspection ALL
     */
    public JComponent $$$getRootComponent$$$() {
        return rootPanel;
    }

    private enum OutputMode {
        ALL,
        WONR,
        MIN
    }

    private JPanel rootPanel;
    private RSyntaxTextArea inputArea;
    private JTextArea outputArea;
    private JTable leakageTable;
    private JLabel parserErrorLabel;
    private RTextScrollPane inputScrollArea;
    private RSyntaxTextArea ssaArea;
    private JTable nodeValueTable;
    private JScrollPane nodeValueScrollPane;
    private JComboBox storeSelectComboBox;
    private JButton storeButton;
    private JScrollPane variableValueScrollPane;
    private JTable variableValueTable;
    private JButton storeJsonButton;
    private JComboBox modeComboBox;
    private JCheckBox autoRunCheckBox;
    private JButton runButton;
    private JButton stopButton;
    private JComboBox methodHandlerSelectionComboxBox;
    private JComboBox outputModeComboxBox;
    private JCheckBox transformPlusCheckBox;
    private JComboBox layoutSelectionComboxBox;
    private JComboBox minCutAlgoComboBox;
    private JComboBox fontSizeMultiplierComboBox;
    private JLabel bitWidthLabel;
    private DotPanel dotPanel;
    private JCheckBox transformLoopsCheckBox;
    private RSyntaxTextArea withoutLoopsArea;
    private JCheckBox recordAlternativesCheckBox;
    private JButton launchDotsButton;
    private Context context = null;
    private DocumentListener documentListener;
    private ResponsiveTimer parseRefreshTimer;
    private ResponsiveTimer processRefreshTimer;
    private Object syntaxErrorHighlightTag = null;
    private Object nodeSelectHighlightTag = null;
    private boolean inLoadComboxBoxHandler = false;
    private boolean inMHComboxBoxHandler = false;
    private OutputMode outputMode;
    private final String VAR_FILE = "gui.config";
    private Properties properties;
    private ResponsiveTimer propertiesWriteTimer;
    private Set<DotPanel> launchedDotFrames = new HashSet<>();

    public BasicUI() {
        properties = new Properties();
        //$$$setupUI$$$();
        $$$setupUI$$$();
        try {
            properties.load(new FileReader(VAR_FILE));
        } catch (IOException e) {
            e.printStackTrace();
        }
        propertiesWriteTimer = new ResponsiveTimer(this::writeVarsToFile);
        propertiesWriteTimer.start();
        documentListener = new DocumentListener() {
            @Override
            public void insertUpdate(DocumentEvent e) {
                if (processRefreshTimer != null) {
                    processRefreshTimer.request();
                }
                if (parseRefreshTimer != null) {
                    parseRefreshTimer.request();
                }
            }

            @Override
            public void removeUpdate(DocumentEvent e) {
                insertUpdate(e);
            }

            @Override
            public void changedUpdate(DocumentEvent e) {
                insertUpdate(e);
            }
        };
        inputArea.getDocument().addDocumentListener(documentListener);
        inputArea.setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_JAVA);
        inputArea.setCodeFoldingEnabled(true);
        inputArea.setMarkOccurrences(true);
        inputArea.setAutoIndentEnabled(true);
        inputArea.setCloseCurlyBraces(true);
        inputArea.setCodeFoldingEnabled(true);
        inputScrollArea.setLineNumbersEnabled(true);
        inputScrollArea.setFoldIndicatorEnabled(true);
        ssaArea.setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_JAVA);
        ssaArea.setMarkOccurrences(true);
        withoutLoopsArea.setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_JAVA);
        withoutLoopsArea.setMarkOccurrences(true);
        CompletionProvider provider = createCompletionProvider();
        AutoCompletion ac = new AutoCompletion(provider);
        ac.install(inputArea);

        boolean shouldAutoRun = getVarContent("lastAutoRun", "true").equals("true");
        autoRunCheckBox.setSelected(shouldAutoRun);
        transformPlusCheckBox.setSelected(getVarContent("lastTransformPlus", "false").equals("true"));
        transformPlusCheckBox.addActionListener(e -> {
            processRefreshTimer.request();
            setVarContent("lastTransformPlus", transformPlusCheckBox.isSelected() + "");
        });
        transformLoopsCheckBox.setSelected(getVarContent("lastTransformLoops", "true").equals("true"));
        transformLoopsCheckBox.addActionListener(e -> {
            processRefreshTimer.request();
            setVarContent("lastTransformLoops", transformLoopsCheckBox.isSelected() + "");
        });
        recordAlternativesCheckBox.setSelected(getVarContent("lastRecordAlternatives", "true").equals("true"));
        recordAlternativesCheckBox.addActionListener(e -> {
            processRefreshTimer.request();
            setVarContent("lastRecordAlternatives", recordAlternativesCheckBox.isSelected() + "");
        });
        for (Context.Mode mode : Context.Mode.values()) {
            modeComboBox.addItem(mode);
        }
        modeComboBox.setSelectedItem(Context.Mode.valueOf(getVarContent("lastMode", Context.Mode.LOOP.name())));
        modeComboBox.addActionListener(a -> {
            Context.Mode mode = (Context.Mode) modeComboBox.getSelectedItem();
            setVarContent("lastMode", mode.name());
            processRefreshTimer.request();
        });
        for (OutputMode mode : OutputMode.values()) {
            outputModeComboxBox.addItem(mode);
        }
        setOutputMode(OutputMode.valueOf(getVarContent("lastOutputMode", OutputMode.WONR.name())));
        outputModeComboxBox.setSelectedItem(outputMode);
        outputModeComboxBox.addActionListener(a -> {
            setOutputMode((OutputMode) outputModeComboxBox.getSelectedItem());
            processRefreshTimer.request();
        });
        for (MinCut.Algo algo : MinCut.Algo.values()) {
            minCutAlgoComboBox.addItem(algo);
        }
        minCutAlgoComboBox.setSelectedItem(MinCut.Algo.valueOf(getVarContent("lastMinCutAlgo", MinCut.usedAlgo.name())));
        minCutAlgoComboBox.addActionListener(a -> {
            MinCut.Algo algo = (MinCut.Algo) minCutAlgoComboBox.getSelectedItem();
            setVarContent("lastMinCutAlgo", algo.name());
            MinCut.usedAlgo = algo;
        });
        processRefreshTimer = new ResponsiveTimer(() -> {
            parseRefreshTimer.abort();
            processAndUpdate(inputArea.getText());
        }, () -> runButton.setText("…"), d -> {
            runButton.setText("\uD83E\uDC92");
        });
        processRefreshTimer.setAutoRun(shouldAutoRun);
        processRefreshTimer.start();
        parseRefreshTimer = new ResponsiveTimer(() -> {
            if (!autoRunCheckBox.isSelected()) {
                parse();
            }
        });
        parseRefreshTimer.start();
        storeSelectComboBox.addActionListener(a -> {
            if (inLoadComboxBoxHandler) {
                return;
            }
            String name = (String) storeSelectComboBox.getSelectedItem();
            storeSelectComboBox.removeAllItems();
            for (String n : getExampleNames()) {
                storeSelectComboBox.addItem(n);
            }
            storeLastName(name);
            load(name);
            inLoadComboxBoxHandler = true;
            storeSelectComboBox.setSelectedItem(getLastName());
            inLoadComboxBoxHandler = false;
        });
        String lastContent = getLastContent();
        inLoadComboxBoxHandler = true;
        for (String n : getExampleNames()) {
            storeSelectComboBox.addItem(n);
        }
        storeSelectComboBox.setSelectedItem(getLastName());
        inLoadComboxBoxHandler = false;
        methodHandlerSelectionComboxBox.addActionListener(a -> {
            if (inMHComboxBoxHandler) {
                return;
            }
            String props = (String) methodHandlerSelectionComboxBox.getSelectedItem();
            try {
                MethodInvocationHandler.parse(props);
                methodHandlerSelectionComboxBox.removeAllItems();
                storeMethodHandlerPropString(props);
                for (String n : getExampleMethodHandlerPropStrings()) {
                    methodHandlerSelectionComboxBox.addItem(n);
                }
                inMHComboxBoxHandler = true;
                methodHandlerSelectionComboxBox.setSelectedItem(props);
                inMHComboxBoxHandler = false;
                processRefreshTimer.request();
                if (parserErrorLabel.getText().contains("method invocation handler")) {
                    parserErrorLabel.setText("");
                }
            } catch (NildumuError e) {
                parserErrorLabel.setText(e.getMessage());
                addOutput(e.getMessage());
                e.printStackTrace();
            }
        });
        String props = getVarContent("lastMHProps", MethodInvocationHandler.getDefaultPropString());
        inMHComboxBoxHandler = true;
        for (String n : getExampleMethodHandlerPropStrings()) {
            methodHandlerSelectionComboxBox.addItem(n);
        }
        methodHandlerSelectionComboxBox.setSelectedItem(props);
        inMHComboxBoxHandler = false;
        stopButton.addActionListener(e -> {
            if (processRefreshTimer != null) {
                processRefreshTimer.abort();
            }
        });
        runButton.addActionListener(e -> {
            new Thread(() -> {
                processRefreshTimer.abort();
                processRefreshTimer.run();
            }).start();
        });
        autoRunCheckBox.addActionListener(e -> {
            processRefreshTimer.setAutoRun(autoRunCheckBox.isSelected());
            setVarContent("lastAutoRun", autoRunCheckBox.isSelected() + "");
        });
        transformPlusCheckBox.setText("+ → &!|^");
        inputArea.setText(lastContent);
        float fontMultiplier = Float.valueOf(getVarContent("fontMultiplier", "1"));
        changeFontSize(fontMultiplier);
        fontSizeMultiplierComboBox.setSelectedItem(String.format("%d%%", Math.round(fontMultiplier * 100)));
        fontSizeMultiplierComboBox.addActionListener(l -> {
            changeFontSize(Float.parseFloat(fontSizeMultiplierComboBox.getSelectedItem().toString().replace("%", "")) / 100);
        });
        storeButton.addActionListener(l -> store(storeSelectComboBox.getSelectedItem().toString()));
    }

    public void processAndUpdate(String program) {
        if (program.isEmpty()) {
            return;
        }
        storeLastContent(program);
        clearOutput();
        parserErrorLabel.setText("");
        if (syntaxErrorHighlightTag != null) {
            inputArea.getHighlighter().removeHighlight(syntaxErrorHighlightTag);
        }
        if (nodeSelectHighlightTag != null) {
            inputArea.getHighlighter().removeHighlight(nodeSelectHighlightTag);
        }
        if (shouldUpdateVariableValueTable()) {
            DotRegistry.get().enable();
        } else {
            DotRegistry.get().disable();
        }
        try {
            Parser.ProgramNode programNode = process(program);
            setMiscInfo(program, programNode);
            Context.Mode mode = (Context.Mode) modeComboBox.getSelectedItem();
            long time = System.currentTimeMillis();
            int opts = 0;
            if (transformPlusCheckBox.isSelected()) {
                opts |= Processor.TRANSFORM_PLUS;
            }
            if (transformLoopsCheckBox.isSelected()) {
                opts |= Processor.TRANSFORM_LOOPS;
            }
            if (recordAlternativesCheckBox.isSelected()) {
                opts |= Processor.RECORD_ALTERNATIVES;
            }
            Context c = Processor.process(program, mode, MethodInvocationHandler.parse(methodHandlerSelectionComboxBox.getSelectedItem().toString()), opts);
            if (context == null || c.sl != context.sl) {
                context = c;
            }
            context = c;
            long analysisTime = System.currentTimeMillis() - time;
            updateLeakageTable(context);
            addOutput(String.format("Analysis: %,dms, #Bits: %,d", analysisTime, Bit.getNumberOfCreatedBits()));
            addOutput(String.format("#Nodes: %,d", Parser.MJNode.getCurrentIdCount()));
            addOutput(String.format("Node version updates: %,d", context.getNodeVersionUpdateCount()));
            addOutput(String.format("#Created frames: %,d", context.numberOfMethodFrames()));
            addOutput(String.format("#Nodes with infinite weight: %,d", context.numberOfinfiniteWeightNodes()));
            if (shouldUpdateNodeValueTable()) {
                updateNodeValueTable(context);
            }
            if (shouldUpdateVariableValueTable()) {
                updateVariableValueTable(context);
            }
            launchedDotFrames.forEach(DotPanel::outerUpdate);
            context.sl.elements().forEach(s -> {
                DotRegistry.get().store("main", "Attacker level: " + s,
                        () -> () -> DotRegistry.visuLeakageDotGraph(context, "", s));
            });
            updateLeakageTable(c);
            context.checkInvariants();
        } catch (LocatedSWPException e) {
            parserErrorLabel.setText(e.getMessage());
            Location errorLocation = e.errorToken.location;
            int startOffset = 0;
            try {
                startOffset = inputArea.getLineStartOffset(errorLocation.line - 1) + errorLocation.column;
                syntaxErrorHighlightTag = inputArea.getHighlighter().addHighlight(startOffset, startOffset + e.errorToken.value.length(), new SquiggleUnderlineHighlightPainter(Color.red));
                inputArea.invalidate();
                inputArea.repaint();
            } catch (BadLocationException e1) {
                e1.printStackTrace();
            }
        } catch (Parser.MJError e) {
            parserErrorLabel.setText(e.getMessage());
        } catch (NildumuError e) {
            addOutput(e.getMessage());
            parserErrorLabel.setText(e.getMessage());
        } catch (RuntimeException e) {
            parserErrorLabel.setText(e.getMessage());
            e.printStackTrace();
        }
    }

    boolean shouldUpdateVariableValueTable() {
        return outputMode.ordinal() <= OutputMode.WONR.ordinal();
    }

    boolean shouldUpdateNodeValueTable() {
        return outputMode.ordinal() <= OutputMode.ALL.ordinal();
    }

    boolean shouldUpdateGraph() {
        return getVarContent("lastAutoDraw", "true").equals("true");
    }

    boolean shouldLogOnStdOut() {
        return outputMode == OutputMode.ALL;
    }

    void setOutputMode(OutputMode newMode) {
        outputMode = newMode;
        setVarContent("lastOutputMode", outputMode.name());
        if (outputMode == OutputMode.ALL) {
            Context.LOG.setLevel(Level.FINE);
        } else {
            Context.LOG.setLevel(Level.WARNING);
        }
    }

    Parser.ProgramNode process(String program) {
        return Parser.process(program, transformPlusCheckBox.isSelected(), transformLoopsCheckBox.isSelected());
    }

    void parse() {
        parserErrorLabel.setText("");
        String program = inputArea.getText();
        if (program.isEmpty()) {
            return;
        }
        storeLastContent(program);
        clearOutput();
        if (syntaxErrorHighlightTag != null) {
            inputArea.getHighlighter().removeHighlight(syntaxErrorHighlightTag);
        }
        if (nodeSelectHighlightTag != null) {
            inputArea.getHighlighter().removeHighlight(nodeSelectHighlightTag);
        }
        try {
            Parser.ProgramNode programNode = process(program);
            setMiscInfo(program, programNode);
        } catch (LocatedSWPException e) {
            parserErrorLabel.setText(e.getMessage());
            Location errorLocation = e.errorToken.location;
            int startOffset = 0;
            try {
                startOffset = inputArea.getLineStartOffset(errorLocation.line - 1) + errorLocation.column;
                syntaxErrorHighlightTag = inputArea.getHighlighter().addHighlight(startOffset, startOffset + e.errorToken.value.length(), new SquiggleUnderlineHighlightPainter(Color.red));
                inputArea.invalidate();
                inputArea.repaint();
            } catch (BadLocationException e1) {
                e1.printStackTrace();
            }
        } catch (Parser.MJError e) {
            parserErrorLabel.setText(e.getMessage());
        } catch (NildumuError e) {
            addOutput(e.getMessage());
            parserErrorLabel.setText(e.getMessage());
        } catch (RuntimeException e) {
            parserErrorLabel.setText(e.getMessage());
            e.printStackTrace();
        }
    }

    private void setMiscInfo(String program, Parser.ProgramNode programNode) {
        ssaArea.setText(programNode.toPrettyString());
        try {
            Parser.ProgramNode p = Parser.parse(program);
            LoopTransformer.process(p);
            withoutLoopsArea.setText(p.toPrettyString());
        } catch (Exception ex) {
        }
        bitWidthLabel.setText(programNode.context.maxBitWidth + "");
    }

    private static class SecWrapper {
        final Sec<?> sec;

        private SecWrapper(Sec<?> sec) {
            this.sec = sec;
        }

        @Override
        public String toString() {
            return "Attacker level: " + sec;
        }

        @Override
        public boolean equals(Object obj) {
            return obj != null && obj.getClass() == this.getClass() && toString().equals(obj.toString());
        }
    }

    private void clearOutput() {
        outputArea.setText("");
    }

    private void addOutput(String str) {
        outputArea.append("\n" + str);
    }

    private void updateLeakageTable(Context context) {
        List<Sec<?>> secLevels = new ArrayList<>((Set<Sec<?>>) context.sl.elements());
        Map<Sec<?>, MinCut.ComputationResult> compRes = context.computeLeakage((MinCut.Algo) minCutAlgoComboBox.getSelectedItem());
        leakageTable.setTableHeader(new JTableHeader());
        leakageTable.setModel(new AbstractTableModel() {

            @Override
            public int getRowCount() {
                return secLevels.size();
            }

            @Override
            public int getColumnCount() {
                return 2;
            }

            @Override
            public Object getValueAt(int rowIndex, int columnIndex) {
                if (columnIndex == 0) {
                    return secLevels.get(rowIndex);
                }
                return compRes.get(secLevels.get(rowIndex)).maxFlow;
            }

            @Override
            public String getColumnName(int column) {
                switch (column) {
                    case 0:
                        return "Attacker level";
                    case 1:
                        return "Leakage in bits";
                }
                return "";
            }
        });
    }

    private void updateNodeValueTable(Context context) {
        nodeValueTable.setModel(new AbstractTableModel() {

            final String[] headers = new String[]{"node", "literal", "basic", "repr"};

            List<Parser.MJNode> nodes = new ArrayList<>(context.nodes());

            @Override
            public int getRowCount() {
                return nodes.size();
            }

            @Override
            public int getColumnCount() {
                return 4;
            }

            @Override
            public Object getValueAt(int rowIndex, int columnIndex) {
                if (nodes.get(rowIndex) == null) {
                    return "";
                }
                switch (columnIndex) {
                    case 0:
                        return nodes.get(rowIndex).getTextualId();
                    case 1:
                        return context.nodeValue(nodes.get(rowIndex)).toLiteralString();
                    case 2:
                        return context.nodeValue(nodes.get(rowIndex)).toString();
                    case 3:
                        return context.nodeValue(nodes.get(rowIndex)).repr();
                }
                return "";
            }

            @Override
            public String getColumnName(int column) {
                return headers[column];
            }
        });
        resizeTable(nodeValueTable);
    }

    private void updateVariableValueTable(Context context) {
        variableValueTable.setModel(new AbstractTableModel() {

            final String[] headers = new String[]{"variable", "literal", "basic", "repr"};

            List<String> variableNames = new ArrayList<>(context.variableNames());

            @Override
            public int getRowCount() {
                return variableNames.size();
            }

            @Override
            public int getColumnCount() {
                return 4;
            }

            @Override
            public Object getValueAt(int rowIndex, int columnIndex) {
                Value val = context.getVariableValue(variableNames.get(rowIndex));
                switch (columnIndex) {
                    case 0:
                        return variableNames.get(rowIndex);
                    case 1:
                        return val.toLiteralString();
                    case 2:
                        return val.toString();
                    case 3:
                        return val.repr();
                }
                return "";
            }

            @Override
            public String getColumnName(int column) {
                return headers[column];
            }
        });
        resizeTable(variableValueTable);
    }

    private void setProgram(String program) {
        inputArea.getDocument().removeDocumentListener(documentListener);
        inputArea.setText(program);
        processRefreshTimer.request();
        inputArea.getDocument().addDocumentListener(documentListener);
    }

    private CompletionProvider createCompletionProvider() {

        DefaultCompletionProvider provider = new DefaultCompletionProvider();
        Arrays.asList(
                "output",
                "input",
                "int",
                "use_sec",
                "diamond",
                "basic"
        ).forEach(a -> provider.addCompletion(new BasicCompletion(provider, a)));

        Arrays.asList(p("hi", "h input int"),
                p("lo", "l output int"),
                p("diamond", "use_sec diamond;"),
                p("a", "low append"))
                .forEach(p -> provider.addCompletion(new ShorthandCompletion(provider, p.first, p.second)));

        return provider;
    }

    private Path pathForName(String name) {
        return Paths.get("examples", name + ".nd");
    }

    private String nameForPath(Path path) {
        return path.getName(path.getNameCount() - 1).toString().split("\\.nd")[0];
    }

    private List<String> getExampleNames() {
        try {
            return Files.list(Paths.get("examples")).filter(p -> p.toString().endsWith(".nd")).map(this::nameForPath).collect(Collectors.toList());
        } catch (IOException e) {
            e.printStackTrace();
        }
        return Collections.emptyList();
    }

    private void load(String name) {
        try {
            setProgram(String.join("\n", Files.readAllLines(pathForName(name))));
        } catch (IOException e) {
            e.printStackTrace();
            addOutput(e.getMessage());
        }
    }

    private void store(String name) {
        try {
            Files.write(pathForName(name), Arrays.asList(inputArea.getText().split("\n")));
        } catch (IOException e) {
            e.printStackTrace();
            addOutput(e.getMessage());
        }
    }

    private void storeLastName(String name) {
        setVarContent("last.var", name);
    }

    private String getLastName() {
        return getVarContent("last.var", "basic");
    }

    private String getLastContent() {
        return getVarContent("lastContent.var", null);
    }

    private void storeLastContent(String content) {
        setVarContent("lastContent.var", content);
    }

    private void setVarContent(String var, String content) {
        properties.setProperty(var, content);
        propertiesWriteTimer.request();
    }

    private String getVarContent(String var, String defaultContent) {
        return properties.getProperty(var, defaultContent);
    }

    private void writeVarsToFile() {
        try {
            properties.store(new FileWriter(VAR_FILE), "gui");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Source: https://tips4java.wordpress.com/2008/11/10/table-column-adjuster/
     */
    private void resizeTable(JTable table) {
        table.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);

        for (int column = 0; column < table.getColumnCount(); column++) {
            TableColumn tableColumn = table.getColumnModel().getColumn(column);
            int preferredWidth = tableColumn.getMinWidth();
            int maxWidth = tableColumn.getMaxWidth();

            for (int row = 0; row < table.getRowCount(); row++) {
                TableCellRenderer cellRenderer = table.getCellRenderer(row, column);
                Component c = table.prepareRenderer(cellRenderer, row, column);
                int width = c.getPreferredSize().width + table.getIntercellSpacing().width;
                preferredWidth = Math.max(preferredWidth, width);

                //  We've exceeded the maximum width, no need to check other rows

                if (preferredWidth >= maxWidth) {
                    preferredWidth = maxWidth;
                    break;
                }
            }

            tableColumn.setPreferredWidth(preferredWidth);
        }
    }

    public static void main(String[] args) {
        FlatLightLaf.install();
        JFrame frame = new JFrame();
        BasicUI ui = new BasicUI();
        frame.getContentPane().add(ui.rootPanel);
        frame.pack();
        frame.setSize(1500, 800);
        frame.setVisible(true);
        //ui.setProgram("h input int l = 0b0u; l output int o = l;");
        while (frame.isVisible()) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    private void storeMethodHandlerPropString(String props) {
        setVarContent("lastMHProps", props);
        if (!getExampleMethodHandlerPropStrings().contains(props)) {
            List<String> ownProps = new ArrayList<>(Arrays.asList(getVarContent("mhprops", "").split("\n")));
            ownProps.add(props);
            setVarContent("mhprops", String.join("\n", ownProps));
        }
    }

    private List<String> getExampleMethodHandlerPropStrings() {
        List<String> props = new ArrayList<>(MethodInvocationHandler.getExamplePropLines());
        String stored = getVarContent("mhprops", "");
        if (!stored.isEmpty()) {
            props.addAll(Arrays.asList(stored.split("\n")));
        }
        return props;
    }

    private static Map<Object, Integer> oldFontSizes = new HashMap<>();

    private void setFontSizeDefault(float multiplier) {
        // adapted from https://stackoverflow.com/a/6930659
        UIDefaults defaults = UIManager.getDefaults();
        Enumeration e = defaults.keys();
        while (e.hasMoreElements()) {
            Object key = e.nextElement();
            Object value = defaults.get(key);
            if (value instanceof Font) {
                Font font = (Font) value;
                if (!oldFontSizes.containsKey(key)) {
                    oldFontSizes.put(key, key.equals("ComboBox.font") ? 10 : font.getSize());
                }
                defaults.put(key, font.deriveFont(oldFontSizes.get(key) * multiplier));
            }
        }
    }

    private void changeFontSize(float multiplier) {
        setFontSizeDefault(multiplier);
        changeFontSize(multiplier, this.rootPanel);
        setVarContent("fontMultiplier", multiplier + "");
        //rootPanel.invalidate();
        launchedDotFrames.forEach(d -> changeFontSize(multiplier, d));
    }

    public static void changeFontSize(float multiplier, Component component) {
        if (!oldFontSizes.containsKey(component)) {
            oldFontSizes.put(component, component.getFont().getSize());
        }
        component.setFont(component.getFont().deriveFont(oldFontSizes.get(component) * multiplier));
        if (component instanceof Container) {
            Stream.of(((Container) component).getComponents()).forEach(c -> changeFontSize(multiplier, c));
        }
    }

    public void addDotFrame(DotPanel dotFrame) {
        launchedDotFrames.add(dotFrame);
    }

    public void removeDotFrame(DotPanel dotFrame) {
        launchedDotFrames.remove(dotFrame);
    }
}
