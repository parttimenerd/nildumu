/* adapted from I. Sweet, J. M. C. Trilla, C. Scherrer, M. Hicks, and S. Magill */
/* "What's the Over Under? Probabilistic Bounds on Information Leakage" */
/* with 10 ships and 10 evacuees */

h input int[10] Capacity = 0bu{16};
h input int[2][10] Loc = 0bu{16};
int[2] L = {100, 100};
int D = 10;
int N = 100;
int[2][10] berths;
int i = 0;
while (i < length(berths)) {
	berths[i] = {0, 1000};
	i = i + 1; 
}

int is_solution(int[2][10] berths, int N) {
	int sum = 0;
	int i = 0;
	while (i < length(berths)) {
		sum = sum + ((berths[i])[0]);
		i = i + 1;
	}
	return sum >= N;
}

int mid(int[2] pos) {
	return ((pos[0]) + (pos[1])) / 2;
}

int AtLeast(int[10] Capacity, int z, int b) { return Capacity[z] >= b; }

int Nearby(int[2][10] Loc, int z, int[2] l, int d) {
	return abs((Loc[z][0]) - (l[0])) + abs((Loc[z][0]) - (l[0])) <= d;
}

int break = 0;
while (!break) {
	int i = 0;
	while (i < length(berths) && !break) {
		int ask = mid(berths[i]);
		int ok = AtLeast(Capacity, i, ask) && Nearby(Loc, i, L, D);
		if (ok) {
			berths[i] = {ask, berths[i][1]};
		} else {
			berths[i] = {berths[i][0], ask};
		}
		if (is_solution(berths, N)) {
			break = 1;
		}
		i = i + 1;
	}
}

l output int[2][10] b = berths;
